---
title: DFA与NFA
date: 2025/03/01 09:10:04
author: lele
tags:
  - 编译原理
categories:
  - 编译原理
  - 词法分析
---
---

### **1. 什么是有限自动机？**
想象你有一个机器人，它只能记住有限的几种状态（比如“开灯”“关灯”），然后根据你输入的指令（比如按按钮）切换状态。这个机器人就是一个**有限自动机（Finite Automata）**。它的核心功能是：**根据输入序列，判断是否最终处于“接受状态”**（比如“正确完成任务”）。

**举个栗子🌰**：  
自动售货机可以看作有限自动机：
- **状态**：等待投币、已投币、出货中、找零中。
- **输入**：投币、选择商品、取消交易。
- **接受状态**：成功出货（你拿到饮料）。

---

### **2. 确定有限自动机（DFA）**
#### **特点**
- **确定性**：每个状态下，对每个输入符号，**只有一条转移路径**。
- **没有选择困难症**！每一步都明确知道下一步怎么走。

#### **举个栗子🌰**
假设要设计一个DFA，判断二进制数是否以`01`结尾：
- **状态**：  
  - **S0**：初始状态（还没看到任何字符，或者之前的字符不是`0`）。
  - **S1**：已经读到一个`0`，等待`1`。
  - **S2**（接受状态）：成功读到`01`。
- **输入符号**：`0`和`1`。
- **转移规则**：
  - 在S0时：输入`0`→S1，输入`1`→S0。
  - 在S1时：输入`0`→S1，输入`1`→S2。
  - 在S2时：输入`0`→S1，输入`1`→S0。

**执行过程**：  
输入字符串`1001`：  
1. 初始状态S0 → 输入`1` → 留在S0。  
2. 输入`0` → 转移到S1。  
3. 输入`0` → 留在S1。  
4. 输入`1` → 转移到S2（接受状态）。  
结论：字符串以`01`结尾，**接受**！

---

### **3. 非确定有限自动机（NFA）**
#### **特点**
- **不确定性**：一个状态下，对同一个输入符号，**可能有多个转移路径**，甚至**不读输入也能转移（ε转移）**。
- **有选择困难症**！它允许“并行尝试多条路”，只要有一条路能走到接受状态就算成功。

#### **举个栗子🌰**
同样判断二进制数是否以`01`结尾，用NFA设计：
- **状态**：  
  - ​**S0**：初始状态。
  - ​**S1**：已经读到`0`，等待`1`。
  - ​**S2**​（接受状态）：成功读到`01`。
- **输入符号**：`0`、`1`、ε（空输入）。
- **转移规则**：
  - ​**S0**​（初始状态）：
    - 输入`0` → 可以转移到S1 ​**或留在S0**​
    - 输入`1` → 留在S0
  - ​**S1**​（已读到一个`0`）：
      - 输入`1` → 转移到S2（接受状态）
      - 输入`0` → ​**允许留在S1**（因为可能后续还有1）
  - ​**S2**​（接受状态）：任何输入都留在S2

**执行过程**：  
输入字符串`001`：  
1. ​第1个字符0：
	- 分支1：从S0转移到S1
	- 分支2：留在S0
2. 第2个字符0：
	- 分支1（当前在S1）​：
		- 输入0 → 转移到S1
	- 分支2（当前在S0）​：
		- 输入0 → 可能转移到S1或留在S0
			- 分支2.1：转移到S1
			- 分支2.2：留在S0
3. 第3个字符1：
	- 分支1（当前在S1）​：
		- 输入1 → 转移到S2（接受状态）✅
	- 分支2.1（当前在S1）​：
		- 输入1 → 转移到S2（接受状态）✅
	- 分支2.2（当前在S0）​：
		- 输入1 → 留在S0 ❌
结论：存在两条路径到达接受状态S2，因此NFA接受字符串001！

---

### **4. DFA和NFA的联系**
#### **核心联系**
- **能力等价**：DFA和NFA能识别的语言完全相同（都是正则语言）。  
  - 任何NFA都可以转化为等价的DFA（虽然DFA的状态数可能爆炸增长）。
- **用途一致**：都用于词法分析（比如编译器识别变量名、数字等）。

#### **举个转化例子🌰**
把上述NFA转化为DFA：  
- DFA的状态需要覆盖NFA所有可能的状态组合。  
- 比如NFA的S0在输入`0`后可能处于{S0, S1}，这个组合就是DFA的一个新状态。

---

### **5. DFA和NFA的区别**
| **维度**     | **DFA**         | **NFA**               |
| ---------- | --------------- | --------------------- |
| **转移确定性**  | 每个状态+输入→唯一转移路径。 | 一个状态+输入→可能有多个转移路径。    |
| **空转移（ε）** | 不允许。            | 允许（可以不读输入就转移状态）。      |
| **状态转移图**  | 每个箭头必须明确且唯一。    | 同一输入可以有多个箭头，甚至ε箭头。    |
| **实现复杂度**  | 容易实现（直接查表）。     | 需要回溯或并行处理（通常先转化为DFA）。 |
| **状态数量**   | 通常更多（指数级增长）。    | 通常更少（设计更灵活）。          |

---

### **6. 实际应用中的选择**
- **用DFA**：需要高效执行（如编程语言词法分析器）。  
- **用NFA**：设计模式更简单（如正则表达式引擎内部可能用NFA）。

---

### **总结**
- **DFA**：死板但高效，每个步骤明确无歧义。  
- **NFA**：灵活但复杂，允许“猜”正确的路径。  
- **核心思想**：**NFA更接近人类思维**（比如写正则表达式时允许模糊匹配），而**DFA更接近机器执行**（必须明确每一步）。

**建议**：  
学习时先理解NFA的灵活性，再掌握如何转化为DFA，最终在代码中实现DFA！